
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Wed Nov 30 10:38:17 CST 2016
//----------------------------------------------------

package compilador;

import java_cup.runtime.Symbol;
import java.util.Stack;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Wed Nov 30 10:38:17 CST 2016
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\073\000\002\004\003\000\002\002\004\000\002\005" +
    "\003\000\002\012\004\000\002\012\004\000\002\012\005" +
    "\000\002\012\005\000\002\013\006\000\002\013\003\000" +
    "\002\013\003\000\002\013\006\000\002\013\006\000\002" +
    "\013\013\000\002\013\003\000\002\013\003\000\002\024" +
    "\006\000\002\025\005\000\002\015\003\000\002\015\005" +
    "\000\002\016\003\000\002\016\003\000\002\016\003\000" +
    "\002\016\003\000\002\027\012\000\002\031\007\000\002" +
    "\030\003\000\002\030\005\000\002\030\002\000\002\026" +
    "\003\000\002\026\005\000\002\026\002\000\002\021\003" +
    "\000\002\021\005\000\002\021\005\000\002\021\004\000" +
    "\002\021\003\000\002\021\005\000\002\023\005\000\002" +
    "\017\003\000\002\017\003\000\002\022\003\000\002\022" +
    "\003\000\002\022\003\000\002\022\003\000\002\022\003" +
    "\000\002\022\003\000\002\020\003\000\002\020\003\000" +
    "\002\006\003\000\002\006\003\000\002\011\003\000\002" +
    "\011\004\000\002\014\003\000\002\014\004\000\002\007" +
    "\005\000\002\010\003\000\002\010\004\000\002\002\003" +
    "\000\002\003\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\150\000\022\004\012\005\026\007\022\010\017\026" +
    "\015\031\005\035\011\041\004\001\002\000\004\004\012" +
    "\001\002\000\012\004\012\013\050\032\061\034\063\001" +
    "\002\000\006\012\ufff3\027\ufff3\001\002\000\006\011\122" +
    "\034\127\001\002\000\006\012\uffd1\027\uffd1\001\002\000" +
    "\004\034\110\001\002\000\054\004\uffc7\006\uffc7\011\uffc7" +
    "\012\uffc7\014\uffc7\015\uffc7\016\uffc7\017\uffc7\020\uffc7\021" +
    "\uffc7\022\uffc7\023\uffc7\024\uffc7\025\uffc7\027\uffc7\030\uffc7" +
    "\033\uffc7\034\uffc7\036\uffc7\037\uffc7\040\uffc7\001\002\000" +
    "\006\012\ufff9\027\ufff9\001\002\000\054\004\uffc8\006\uffc8" +
    "\011\uffc8\012\uffc8\014\uffc8\015\uffc8\016\uffc8\017\uffc8\020" +
    "\uffc8\021\uffc8\022\uffc8\023\uffc8\024\uffc8\025\uffc8\027\uffc8" +
    "\030\uffc8\033\uffc8\034\uffc8\036\uffc8\037\uffc8\040\uffc8\001" +
    "\002\000\012\004\012\013\050\032\061\034\063\001\002" +
    "\000\006\012\ufff8\027\ufff8\001\002\000\004\004\012\001" +
    "\002\000\006\012\ufff4\027\ufff4\001\002\000\006\012\uffd0" +
    "\027\uffd0\001\002\000\010\004\012\012\uffcf\027\uffcf\001" +
    "\002\000\004\002\001\001\002\000\004\002\040\001\002" +
    "\000\006\012\034\027\035\001\002\000\004\004\012\001" +
    "\002\000\004\002\uffff\001\002\000\006\004\012\006\uffca" +
    "\001\002\000\004\006\032\001\002\000\006\012\uffcb\027" +
    "\uffcb\001\002\000\004\006\uffc9\001\002\000\030\002\ufffe" +
    "\004\012\005\026\007\022\010\017\012\ufffe\026\015\027" +
    "\ufffe\031\005\035\011\041\004\001\002\000\030\002\ufffd" +
    "\004\012\005\026\007\022\010\017\012\ufffd\026\015\027" +
    "\ufffd\031\005\035\011\041\004\001\002\000\010\002\ufffc" +
    "\012\ufffc\027\ufffc\001\002\000\010\002\ufffb\012\ufffb\027" +
    "\ufffb\001\002\000\004\002\000\001\002\000\010\004\012" +
    "\012\uffcd\027\uffcd\001\002\000\006\012\uffce\027\uffce\001" +
    "\002\000\006\012\uffcc\027\uffcc\001\002\000\004\011\045" +
    "\001\002\000\006\004\012\013\050\001\002\000\022\012" +
    "\ufff0\014\055\015\054\016\052\017\053\027\ufff0\033\ufff0" +
    "\040\ufff0\001\002\000\044\012\uffd3\014\uffd3\015\uffd3\016" +
    "\uffd3\017\uffd3\020\uffd3\021\uffd3\022\uffd3\023\uffd3\024\uffd3" +
    "\025\uffd3\027\uffd3\030\uffd3\033\uffd3\036\uffd3\037\uffd3\040" +
    "\uffd3\001\002\000\044\012\uffd2\014\uffd2\015\uffd2\016\uffd2" +
    "\017\uffd2\020\uffd2\021\uffd2\022\uffd2\023\uffd2\024\uffd2\025" +
    "\uffd2\027\uffd2\030\uffd2\033\uffd2\036\uffd2\037\uffd2\040\uffd2" +
    "\001\002\000\006\012\ufffa\027\ufffa\001\002\000\006\004" +
    "\uffed\013\uffed\001\002\000\006\004\uffec\013\uffec\001\002" +
    "\000\006\004\uffee\013\uffee\001\002\000\006\004\uffeb\013" +
    "\uffeb\001\002\000\006\004\012\013\050\001\002\000\012" +
    "\012\uffef\027\uffef\033\uffef\040\uffef\001\002\000\030\012" +
    "\uffe2\020\071\021\073\022\105\023\100\024\101\025\076" +
    "\030\uffe2\033\uffe2\036\077\037\102\001\002\000\012\004" +
    "\012\013\050\032\061\034\063\001\002\000\014\012\uffde" +
    "\020\071\021\073\030\uffde\033\uffde\001\002\000\012\004" +
    "\012\013\050\032\061\034\063\001\002\000\004\030\065" +
    "\001\002\000\022\004\012\005\026\007\022\010\017\026" +
    "\015\031\005\035\011\041\004\001\002\000\006\012\ufff7" +
    "\027\ufff7\001\002\000\004\033\070\001\002\000\014\012" +
    "\uffdc\020\uffdc\021\uffdc\030\uffdc\033\uffdc\001\002\000\012" +
    "\004\uffdb\013\uffdb\032\uffdb\034\uffdb\001\002\000\012\004" +
    "\012\013\050\032\061\034\063\001\002\000\012\004\uffda" +
    "\013\uffda\032\uffda\034\uffda\001\002\000\010\012\uffdd\030" +
    "\uffdd\033\uffdd\001\002\000\010\012\uffdf\030\uffdf\033\uffdf" +
    "\001\002\000\006\004\uffd6\013\uffd6\001\002\000\006\004" +
    "\uffd5\013\uffd5\001\002\000\006\004\uffd8\013\uffd8\001\002" +
    "\000\006\004\uffd7\013\uffd7\001\002\000\006\004\uffd4\013" +
    "\uffd4\001\002\000\012\004\012\013\050\032\061\034\063" +
    "\001\002\000\006\004\012\013\050\001\002\000\006\004" +
    "\uffd9\013\uffd9\001\002\000\010\012\uffe0\030\uffe0\033\uffe0" +
    "\001\002\000\010\012\uffe1\030\uffe1\033\uffe1\001\002\000" +
    "\004\004\012\001\002\000\012\004\012\013\050\032\061" +
    "\034\063\001\002\000\004\011\113\001\002\000\006\004" +
    "\012\013\050\001\002\000\004\012\115\001\002\000\012" +
    "\004\ufff2\013\ufff2\032\ufff2\034\ufff2\001\002\000\004\012" +
    "\117\001\002\000\004\004\012\001\002\000\004\033\124" +
    "\001\002\000\004\011\122\001\002\000\006\004\012\013" +
    "\050\001\002\000\010\012\ufff1\027\ufff1\033\ufff1\001\002" +
    "\000\004\030\125\001\002\000\022\004\012\005\026\007" +
    "\022\010\017\026\015\031\005\035\011\041\004\001\002" +
    "\000\006\012\ufff5\027\ufff5\001\002\000\010\004\012\013" +
    "\050\033\uffe6\001\002\000\004\033\134\001\002\000\006" +
    "\033\uffe8\040\132\001\002\000\010\004\012\013\050\033" +
    "\uffe6\001\002\000\004\033\uffe7\001\002\000\004\012\135" +
    "\001\002\000\006\012\uffe9\027\uffe9\001\002\000\004\030" +
    "\137\001\002\000\022\004\012\005\026\007\022\010\017" +
    "\026\015\031\005\035\011\041\004\001\002\000\006\012" +
    "\ufff6\027\ufff6\001\002\000\004\034\142\001\002\000\006" +
    "\004\012\033\uffe3\001\002\000\006\033\uffe5\040\151\001" +
    "\002\000\004\033\145\001\002\000\004\030\146\001\002" +
    "\000\022\004\012\005\026\007\022\010\017\026\015\031" +
    "\005\035\011\041\004\001\002\000\004\027\150\001\002" +
    "\000\006\012\uffea\027\uffea\001\002\000\006\004\012\033" +
    "\uffe3\001\002\000\004\033\uffe4\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\150\000\032\002\006\003\013\004\023\005\022\006" +
    "\015\007\020\011\007\012\026\013\024\025\012\027\017" +
    "\031\005\001\001\000\006\002\140\003\013\001\001\000" +
    "\014\002\046\003\013\020\057\021\135\023\061\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\002\046\003\013\020\057\021\063\023" +
    "\061\001\001\000\002\001\001\000\006\002\043\003\013" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\002" +
    "\040\003\013\014\041\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\002\027\003\013\010" +
    "\030\001\001\000\002\001\001\000\010\002\027\003\013" +
    "\010\032\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\002\006\003\013\006\015\007\020" +
    "\011\007\012\036\013\024\025\012\027\017\031\005\001" +
    "\001\000\026\002\006\003\013\006\015\007\020\011\007" +
    "\012\035\013\024\025\012\027\017\031\005\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\002\040\003\013\014\042\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\002\046\003\013" +
    "\015\050\020\045\001\001\000\004\016\055\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\002\046\003\013\015\056\020\045\001\001" +
    "\000\002\001\001\000\006\017\102\022\103\001\001\000" +
    "\014\002\046\003\013\020\057\021\074\023\061\001\001" +
    "\000\004\017\071\001\001\000\014\002\046\003\013\020" +
    "\057\021\066\023\061\001\001\000\002\001\001\000\026" +
    "\002\006\003\013\006\015\007\020\011\007\012\065\013" +
    "\024\025\012\027\017\031\005\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\002\046\003\013\020\057\021\073\023\061\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\002\046\003\013\020" +
    "\057\021\106\023\061\001\001\000\010\002\046\003\013" +
    "\020\105\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\002\111\003\013\024\110\001\001" +
    "\000\014\002\046\003\013\020\057\021\115\023\061\001" +
    "\001\000\002\001\001\000\012\002\046\003\013\015\113" +
    "\020\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\002\120\003\013\025\117\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\002\046\003" +
    "\013\015\122\020\045\001\001\000\002\001\001\000\002" +
    "\001\001\000\026\002\006\003\013\006\015\007\020\011" +
    "\007\012\125\013\024\025\012\027\017\031\005\001\001" +
    "\000\002\001\001\000\014\002\046\003\013\015\130\020" +
    "\045\030\127\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\002\046\003\013\015\130\020\045\030\132\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\026\002\006\003\013\006\015\007" +
    "\020\011\007\012\137\013\024\025\012\027\017\031\005" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\002" +
    "\142\003\013\026\143\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\024\002\006\003\013\006" +
    "\015\007\020\011\007\013\146\025\012\027\017\031\005" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\002" +
    "\142\003\013\026\151\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}




/*Declaraciones variables*/
ArrayList <Tokens> listaTokens = new ArrayList<>();
ArrayList <Objeto> listaObj = new ArrayList<>(); 

/*Manejo de erres*/

public void  report_error(String mensaje, Object info){
    StringBuilder m = new StringBuilder("Error ocurrido");
     if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" En la linea "+(s.left));
                if (s.right >= 0)
                    m.append(", columna "+(s.right));
                    if(s.sym == 1)
                        m.append(" Error");
                    if(s.sym == 2)
                        m.append(" Error en declaracion de la variable");
                    if(s.sym == 3)
                        m.append(" Error en inicio comentario");
                    if(s.sym == 4)
                        m.append(" Error en final comentario");
                    if(s.sym == 5)
                        m.append(" Error en Comentario de linea");
                    if(s.sym == 6) 
                        m.append(" Error cerca de la variable");
                    if(s.sym == 7)
                        m.append(" Error en Asignacion");
                    if(s.sym == 8)
                        m.append(" Error en punto coma");
                    if(s.sym == 9)
                        m.append(" Error en numero");
                    if(s.sym == 10)
                        m.append(" Error en operador aritmetico");
                    if(s.sym == 11)
                        m.append(" Error en operador aritmetico");
                    if(s.sym == 12)
                        m.append(" Error en operador aritmetico");
                    if(s.sym == 13)
                        m.append(" Error en operador aritmetico");
                    if(s.sym == 14)
                        m.append(" Error en operador logico");
                    if(s.sym == 15)
                        m.append(" Error en operador logico");
                    if(s.sym == 16)
                        m.append(" Error en operador logico");
                    if(s.sym == 17)
                        m.append(" Error en operador logico");
                    if(s.sym == 18)
                        m.append(" Error en operador logico");
                    if(s.sym == 19)
                        m.append(" Error en operador logico");
                    if(s.sym == 20) 
                        m.append(" Error en Declaracion sentencial si");
                    if(s.sym == 21)
                        m.append(" Error en Declaracion apertura bloque");
                    if(s.sym == 22)
                        m.append(" Error en Declaracion cierre bloque");
                    if(s.sym == 23)
                        m.append(" Error en Declaracion sentencial mientras");
                    if(s.sym == 24)
                        m.append(" Error en operador logico");
                    if(s.sym == 25)
                        m.append(" Error en parentesis derecho");
                    if(s.sym == 26)
                        m.append(" Error en parentesis izquierdo");
                    if(s.sym == 27)
                        m.append(" Error en Declaracion sentencial para");
                    if(s.sym == 28)
                        m.append(" Error en operador menor");
                    if(s.sym == 29)
                        m.append(" Error en operador mayor");
                    if(s.sym == 30)
                        m.append(" Error en coma");
                    if(s.sym == 31)
                        m.append(" Error en final declaracion");
            }
        }
        m.append(" : "+mensaje);
        System.err.println(m);
    }





void agregarToken(Tokens nuevoToken){
    if(!existeToken(nuevoToken.getLlave())){
       listaTokens.add(nuevoToken);
    }else{
        System.err.println("el token ya existe: Error Semantico");
    }
    
}



void agregar_obj(Objeto nuevo){
    listaObj.add(nuevo);
}

boolean existeToken(String llave){
    for(Tokens token:listaTokens){
        if(token.getLlave().equals(llave)){
            return true;
        }
    }
    return false;
}

public void imprimirtokens(){
     for(int ind=0; ind < listaTokens.size(); ind ++){
        Tokens temp = listaTokens.get(ind);
        System.out.println(temp.getLlave());
        System.out.println(temp.getValor());
    }
}

public void imprimirtabla(){
     for(int ind=0; ind < listaObj.size(); ind ++){
        Objeto temp = listaObj.get(ind);
        System.out.println("Nombre Variable: " + temp.getNombre());
        System.out.println("Valor de la variable: " + temp.getValor());
        System.out.println("tipo de la variable: " + temp.getTipo());
        System.out.println();
    }
}



String Code = "";
ExpBinaria expBinaria = null;
public void unrecovered_sintax_error(Symbol s) throws java.lang.Exception{

}




void ejecutar() throws IOException{
String ruta = "/home/annia/NetBeansProjects/Compilador/src/compilador/codigo.asm";
File archivo = new File(ruta);
BufferedWriter bw;
if(archivo.exists()) {
      bw = new BufferedWriter(new FileWriter(archivo));
      bw.write(Code);
} else {
      bw = new BufferedWriter(new FileWriter(archivo));
      bw.write(Code);
}
 bw.close();
}


/*Para las salidas en el codigo ensamblador */
void agregarSi(ExpBinaria expBinaria){
    Code = Code+
        "MOV  AX,"+ expBinaria.getExpIzq()+" \n"+
        "MOV  BX,"+ expBinaria.getExpDer()+" \n"+
        "CMP AX, BX \n"+
        "JG MAYOR: \n"+
            ":Codigo Else:"+"\n"+
        "JMP DESPUES \n"+
        "MAYOR: \n"+
            ":Codigo del si: \n"+
        "DESPUES :\n"+
        ":Codigo de Salida:"+"\n";
}

Boolean validarNumerico(String num){
    int prueba;
    try{
        prueba = Integer.parseInt(num);
        return true;
    }catch(Exception e){ 
        return false;
    }
}


void agregarMientras(ExpBinaria expBinaria){
    String condicion = "";
    switch(expBinaria.getOperador()){
        case "==":
            condicion = "JE";
            break;
        case ">":
            condicion = "JG";
            break;
        case "<":
            condicion = "JL";
            break;
        case "<=":
            condicion = "JLE";
            break;
        case ">=":
            condicion = "JGE";
    }
    Code = Code+
        "MOV  AX,"+ expBinaria.getExpIzq()+" \n"+
        "MOV  BX,"+ expBinaria.getExpDer()+" \n"+
        "CMP AX, BX \n"+
        condicion+" DESPUES"+"\n"+  
        "CUMPLE:"+" \n"+
        "Codigo del Mientras"+"\n"+
        "CMP AX, BX \n"+
        condicion+" CUMPLE"+"\n"+        
        "DESPUES :\n"+
        "Codigo de Salida"+"\n";
}

void agregarPara(ExpBinaria expBinaria){
    String condicion = "";
    switch(expBinaria.getOperador()){
        case "==":
            condicion = "JE";
            break;
        case ">":
            condicion = "JG";
            break;
        case "<":
            condicion = "JL";
            break;
        case "<=":
            condicion = "JLE";
            break;
        case ">=":
            condicion = "JGE";
    }
    Code = Code+
        "MOV  AX,"+ expBinaria.getExpIzq()+" \n"+
        "MOV  BX,"+ expBinaria.getExpDer()+" \n"+
        "CMP AX, BX \n"+
        condicion+" DESPUES"+"\n"+  
        "CUMPLE:"+" \n"+
        "INC AX  \n"+
        "Codigo del Para"+"\n"+
        "CMP AX, BX \n"+
        condicion+" CUMPLE"+"\n"+        
        "DESPUES :\n"+
        "Codigo de Salida"+"\n" +
        "/////////////////////////"+"\n";
}




private Stack pila = new Stack();





}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // ident ::= ID 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = id;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ident",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // Doc ::= ident 
            {
              Object RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object variable = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = variable;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Doc",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // block_comment_body ::= Doc block_comment_body 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block_comment_body",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // block_comment_body ::= Doc 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block_comment_body",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // block_comment ::= INI_COMMENT block_comment_body FIN_COMMENT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block_comment",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // cuerpo_linea ::= Doc cuerpo_linea 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_linea",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // cuerpo_linea ::= Doc 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_linea",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // line_comment ::= LINE_COMMENT cuerpo_linea 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("line_comment",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // line_comment ::= LINE_COMMENT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("line_comment",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Comment ::= block_comment 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("Comment",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Comment ::= line_comment 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("Comment",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // exp_def ::= Number 
            {
              Object RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object num = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = num; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_def",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // exp_def ::= Doc 
            {
              Object RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object variable = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = variable; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_def",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ope_compara ::= ope_mayor 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=op; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // ope_compara ::= ope_menor 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=op; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ope_compara ::= ope_mayor_igual 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=op; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // ope_compara ::= ope_menor_igual 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=op; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // ope_compara ::= ope_diferente 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=op; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // ope_compara ::= ope_comp 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_compara",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // ope_logicos ::= ope_or 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_logicos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // ope_logicos ::= ope_and 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ope_logicos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // exp_binaria_p ::= parent_izq exp_binaria parent_derec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria_p",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // exp_binaria ::= exp_binaria_p ope_logicos exp_binaria 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // exp_binaria ::= exp_binaria_p 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // exp_binaria ::= ope_neg exp_binaria 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // exp_binaria ::= exp_def ope_compara exp_def 
            {
              Object RESULT =null;
		int expIzqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expIzqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object expIzq = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expDerleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expDerright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object expDer = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
    String tokenA = expIzq.toString();
    String tokenB = expDer.toString();
    boolean a= parser.validarNumerico(tokenA);
    boolean b= parser.validarNumerico(tokenB);
   
    if(!b&&(!(parser.existeToken(tokenB) == true))){
        System.err.println("error no ha sido inicializada:"+ tokenB + ": Error Semantico");
    }
    
    if(!a&&(!(parser.existeToken(tokenA) == true))){
        System.err.println("error no ha sido inicializada:" + tokenA);
    }
    RESULT = new ExpBinaria(tokenA, tokenB, op.toString()); 

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // exp_binaria ::= exp_def ope_logicos exp_binaria 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // exp_binaria ::= exp_def 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_binaria",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // param_decl ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_decl",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // param_decl ::= Doc coma param_decl 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_decl",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // param_decl ::= Doc 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_decl",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // param_imp ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_imp",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // param_imp ::= exp_stm coma param_imp 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_imp",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // param_imp ::= exp_stm 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_imp",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // fn_imp ::= Doc parent_izq param_imp parent_derec punto_coma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("fn_imp",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // fn_decl ::= senten_fn Doc parent_izq param_decl parent_derec corch_izq decl_stmt corch_derec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("fn_decl",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // arith_op ::= Multipl 
            {
              Object RESULT =null;
		int resleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object res = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    RESULT = res;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arith_op",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // arith_op ::= Divide 
            {
              Object RESULT =null;
		int resleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object res = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    RESULT =res;
    
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arith_op",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // arith_op ::= Resta 
            {
              Object RESULT =null;
		int resleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object res = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = res;
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arith_op",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // arith_op ::= Suma 
            {
              Object RESULT =null;
		int resleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object res = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    RESULT = res;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arith_op",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // exp_stm ::= exp_def arith_op exp_stm 
            {
              Object RESULT =null;
		int term1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int term1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object term1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int term2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int term2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object term2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        System.out.print("Operacion Matematica");
        switch(op.toString()){
            case "+":
                RESULT = Integer.parseInt(term1.toString()) + Integer.parseInt(term2.toString());
                break;
            case "*":
                RESULT = Integer.parseInt(term1.toString()) * Integer.parseInt(term2.toString());
                break;
            case "-":
                RESULT = Integer.parseInt(term1.toString()) - Integer.parseInt(term2.toString());
                break;
            case "/":
                RESULT = Integer.parseInt(term1.toString()) / Integer.parseInt(term2.toString());
                break;
         } 
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_stm",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // exp_stm ::= exp_def 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp_stm",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // asig_op_no_final ::= Doc Asig exp_stm 
            {
              Object RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object variable = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int decl_expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int decl_expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object decl_exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   Objeto obj = new Objeto (variable.toString(), decl_exp.toString() , "enlace");
   parser.agregar_obj(obj); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asig_op_no_final",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // asig_op ::= Doc Asig exp_stm punto_coma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("asig_op",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // decl_stmt ::= fn_imp 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // decl_stmt ::= fn_decl 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // decl_stmt ::= senten_para parent_izq asig_op exp_binaria punto_coma asig_op_no_final parent_derec corch_izq stmt 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		

    parser.agregarPara((ExpBinaria) exp);


              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // decl_stmt ::= senten_mientras exp_binaria corch_izq stmt 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 
    parser.agregarMientras((ExpBinaria) exp);
   // parser.ejecutar();
     

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // decl_stmt ::= senten_si exp_binaria corch_izq stmt 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
    parser.agregarSi((ExpBinaria) exp);
   // parser.ejecutar();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // decl_stmt ::= Comment 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // decl_stmt ::= asig_op_no_final 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // decl_stmt ::= let Doc Asig exp_stm 
            {
              Object RESULT =null;
		int enlleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int enlright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object enl = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object variable = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int decl_expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int decl_expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object decl_exp = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   Tokens token = new Tokens(variable.toString(), decl_exp.toString());
   parser.agregarToken(token);
   Objeto obj = new Objeto (variable.toString(), decl_exp.toString() , enl.toString());
   parser.agregar_obj(obj);


              CUP$parser$result = parser.getSymbolFactory().newSymbol("decl_stmt",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // stmt ::= decl_stmt punto_coma stmt 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // stmt ::= decl_stmt corch_derec stmt 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // stmt ::= decl_stmt corch_derec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // stmt ::= decl_stmt punto_coma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // Ruler ::= stmt 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("Ruler",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Grammar EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Grammar ::= Ruler 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("Grammar",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

